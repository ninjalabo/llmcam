# generated by fastapi-codegen:
#   filename:  modified_openapi.json
#   timestamp: 2024-11-04T22:49:09+00:00

from __future__ import annotations

from datetime import datetime
from typing import List, Optional, Union

from fastapi import FastAPI, Path, Query
from pydantic import confloat

from .models import (
    CameraHistory,
    CountersModel,
    CSVDataModel,
    D2LogicalModel,
    DomainsResponseModel,
    Empty,
    ForecastSectionFeatureCollectionSimpleV1,
    ForecastSectionFeatureCollectionV1,
    ForecastSectionFeatureSimpleV1,
    ForecastSectionFeatureV1,
    ForecastSectionsWeatherDtoV1,
    ForecastSectionWeatherDtoV1,
    JsonDataResponseModelItem,
    LocationFeatureCollectionV1,
    LocationFeatureV1,
    LocationTypesDtoV1,
    LocationVersionDtoV1,
    MaintenanceTrackingDomainDtoV1,
    MaintenanceTrackingFeatureCollectionV1,
    MaintenanceTrackingFeatureV1,
    MaintenanceTrackingLatestFeatureCollectionV1,
    MaintenanceTrackingTaskDtoV1,
    MeasuredDataPublication,
    MeasurementSiteTablePublication,
    PresetHistory,
    RegionGeometryFeatureCollectionV1,
    RoadStationState,
    SituationTypeV1,
    SvgModel,
    TaskIdEnum,
    TmsStationDataDtoV1,
    TmsStationFeatureCollectionSimpleV1,
    TmsStationFeatureDetailedV1,
    TmsStationsDataDtoV1,
    TmsStationSensorConstantDtoV1,
    TmsStationSensorsDtoV1,
    TmsStationsSensorConstantsDataDtoV1,
    TrafficAnnouncementFeatureCollectionV1,
    TrafficSignHistoryV1,
    UpdateInfosDtoV1,
    UserTypesResponseModel,
    VariableSignDescriptions,
    VariableSignFeatureCollectionV1,
    WeathercamStationDataV1,
    WeathercamStationFeatureCollectionSimpleV1,
    WeathercamStationFeatureV1Detailed,
    WeathercamStationsDataV1,
    WeathercamStationsPresetsPublicityHistoryV1,
    WeatherSensorValueHistoryDto,
    WeatherStationDataDtoV1,
    WeatherStationFeatureCollectionSimpleV1,
    WeatherStationFeatureDetailedV1,
    WeatherStationsDataDtoV1,
    WeatherStationSensorsDtoV1,
    XmlModel,
)

app = FastAPI(
    title='Digitraffic Road API',
    description='[OpenAPI document](/swagger/openapi.json) \n\nDigitraffic is a service operated by the [Fintraffic](https://www.fintraffic.fi) offering real time traffic information. Currently the service covers *road, marine and rail* traffic. More information can be found at the [Digitraffic website](https://www.digitraffic.fi/) \n\nThe service has a public Google-group [road.digitraffic.fi](https://groups.google.com/forum/#!forum/roaddigitrafficfi) for communication between developers, service administrators and Fintraffic. The discussion in the forum is mostly in Finnish, but you\'re welcome to communicate in English too. \n\n### General notes of the API\n* Many Digitraffic APIs use GeoJSON as data format. Definition of the GeoJSON format can be found at https://tools.ietf.org/html/rfc7946.\n* For dates and times [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format is used with "Zulu" zero offset from UTC unless otherwise specified (i.e., "yyyy-mm-ddThh:mm:ss[.mmm]Z"). E.g. 2019-11-01T06:30:00Z.',
    termsOfService='https://www.digitraffic.fi/en/terms-of-service/',
    contact={'name': 'Digitraffic / Fintraffic', 'url': 'https://www.digitraffic.fi/'},
    license={
        'name': 'Digitraffic is an open data service. All content from the service and the service documentation is licenced under the Creative Commons 4.0 BY license.',
        'url': 'https://creativecommons.org/licenses/by/4.0/',
    },
    version='Branch: master, tag: 2024.10.28-1 #ef5bdf3 @ 2024-10-29T08:05:03+0000',
)


@app.get(
    '/api/beta/tms-data-datex2.json',
    response_model=MeasuredDataPublication,
    tags=['Beta'],
)
def tms_data_datex2_json() -> MeasuredDataPublication:
    """
    Current data of TMS Stations in Datex2 format (Traffic Measurement System / LAM)
    """
    pass


@app.get(
    '/api/beta/tms-data-datex2.xml',
    response_model=MeasuredDataPublication,
    tags=['Beta'],
)
def tms_data_datex2_xml() -> MeasuredDataPublication:
    """
    Current data of TMS Stations in Datex2 format (Traffic Measurement System / LAM)
    """
    pass


@app.get(
    '/api/beta/tms-stations-datex2.json',
    response_model=MeasurementSiteTablePublication,
    tags=['Beta'],
)
def tms_stations_datex2_json(
    state: Optional[RoadStationState] = None,
) -> MeasurementSiteTablePublication:
    """
    The static information of TMS stations in Datex2 format (Traffic Measurement System / LAM)
    """
    pass


@app.get(
    '/api/beta/tms-stations-datex2.xml',
    response_model=MeasurementSiteTablePublication,
    tags=['Beta'],
)
def tms_stations_datex2_xml(
    state: Optional[RoadStationState] = None,
) -> MeasurementSiteTablePublication:
    """
    The static information of TMS stations in Datex2 format (Traffic Measurement System / LAM)
    """
    pass


@app.get(
    '/api/beta/weather-history-data/{stationId}',
    response_model=List[WeatherSensorValueHistoryDto],
    tags=['Beta'],
)
def weather_data_history(
    station_id: int = Path(..., alias='stationId'),
    from_date: Optional[datetime] = None,
    to_date: Optional[datetime] = None,
) -> List[WeatherSensorValueHistoryDto]:
    """
    List the history of sensor values from the weather road station
    """
    pass


@app.get(
    '/api/beta/weather-history-data/{stationId}/{sensorId}',
    response_model=List[WeatherSensorValueHistoryDto],
    tags=['Beta'],
)
def weather_data_history_1(
    station_id: int = Path(..., alias='stationId'),
    sensor_id: int = Path(..., alias='sensorId'),
    from_date: Optional[datetime] = None,
) -> List[WeatherSensorValueHistoryDto]:
    """
    List the history of sensor value from the weather road station
    """
    pass


@app.get(
    '/api/counting-site/v1/counters',
    response_model=CountersModel,
    responses={'500': {'model': Empty}},
    tags=['Counting site V1'],
)
def get_api_counting_site_v1_counters(
    domain_name: Optional[str] = None,
) -> Union[CountersModel, Empty]:
    """
    Return all counters for domain
    """
    pass


@app.get(
    '/api/counting-site/v1/counters/{counterId}',
    response_model=CountersModel,
    responses={'500': {'model': Empty}},
    tags=['Counting site V1'],
)
def get_api_counting_site_v1_counters_counter_id(
    counter_id: str = Path(..., alias='counterId')
) -> Union[CountersModel, Empty]:
    """
    Return single counter
    """
    pass


@app.get(
    '/api/counting-site/v1/directions', response_model=None, tags=['Counting site V1']
)
def get_api_counting_site_v1_directions() -> None:
    """
    Return all directions
    """
    pass


@app.get(
    '/api/counting-site/v1/domains',
    response_model=DomainsResponseModel,
    responses={'500': {'model': Empty}},
    tags=['Counting site V1'],
)
def get_api_counting_site_v1_domains() -> Union[DomainsResponseModel, Empty]:
    """
    Return all domains
    """
    pass


@app.get(
    '/api/counting-site/v1/user-types',
    response_model=UserTypesResponseModel,
    responses={'500': {'model': Empty}},
    tags=['Counting site V1'],
)
def get_api_counting_site_v1_user_types() -> Union[UserTypesResponseModel, Empty]:
    """
    Return all user types
    """
    pass


@app.get(
    '/api/counting-site/v1/values',
    response_model=List[JsonDataResponseModelItem],
    responses={'500': {'model': Empty}},
    tags=['Counting site V1'],
)
def get_api_counting_site_v1_values(
    year: Optional[str] = None,
    domain_name: Optional[str] = None,
    counter_id: Optional[str] = None,
    month: Optional[str] = None,
) -> Union[List[JsonDataResponseModelItem], Empty]:
    """
    Return counter values.  If no year&month specified, current month will be used.
    """
    pass


@app.get(
    '/api/counting-site/v1/values.csv',
    response_model=CSVDataModel,
    responses={'500': {'model': Empty}},
    tags=['Counting site V1'],
)
def get_api_counting_site_v1_values_csv(
    year: Optional[str] = None,
    domain_name: Optional[str] = None,
    counter_id: Optional[str] = None,
    month: Optional[str] = None,
) -> Union[CSVDataModel, Empty]:
    """
    Return counter values in CSV. If no year&month specified, current month will be used
    """
    pass


@app.get('/api/info/v1/update-times', response_model=UpdateInfosDtoV1, tags=['Info V1'])
def data_updated_infos() -> UpdateInfosDtoV1:
    """
    Infos about apis data update times
    """
    pass


@app.get(
    '/api/maintenance/v1/tracking/domains',
    response_model=List[MaintenanceTrackingDomainDtoV1],
    tags=['Maintenance V1'],
)
def get_maintenance_tracking_domains() -> List[MaintenanceTrackingDomainDtoV1]:
    """
    Road maintenance tracking domains
    """
    pass


@app.get(
    '/api/maintenance/v1/tracking/routes',
    response_model=MaintenanceTrackingFeatureCollectionV1,
    tags=['Maintenance V1'],
)
def find_maintenance_trackings(
    end_from: Optional[datetime] = Query(None, alias='endFrom'),
    end_before: Optional[datetime] = Query(None, alias='endBefore'),
    created_after: Optional[datetime] = Query(None, alias='createdAfter'),
    created_before: Optional[datetime] = Query(None, alias='createdBefore'),
    x_min: Optional[confloat(ge=19.0, le=32.0)] = Query(19, alias='xMin'),
    y_min: Optional[confloat(ge=59.0, le=72.0)] = Query(59, alias='yMin'),
    x_max: Optional[confloat(ge=19.0, le=32.0)] = Query(32, alias='xMax'),
    y_max: Optional[confloat(ge=59.0, le=72.0)] = Query(72, alias='yMax'),
    task_id: Optional[List[TaskIdEnum2]] = Query(None, alias='taskId'),
    domain: Optional[List[str]] = ['state-roads'],
) -> MaintenanceTrackingFeatureCollectionV1:
    """
    Road maintenance tracking routes
    """
    pass


@app.get(
    '/api/maintenance/v1/tracking/routes/latest',
    response_model=MaintenanceTrackingLatestFeatureCollectionV1,
    tags=['Maintenance V1'],
)
def find_latest_maintenance_trackings(
    end_from: Optional[datetime] = Query(None, alias='endFrom'),
    x_min: Optional[confloat(ge=19.0, le=32.0)] = Query(19, alias='xMin'),
    y_min: Optional[confloat(ge=59.0, le=72.0)] = Query(59, alias='yMin'),
    x_max: Optional[confloat(ge=19.0, le=32.0)] = Query(32, alias='xMax'),
    y_max: Optional[confloat(ge=59.0, le=72.0)] = Query(72, alias='yMax'),
    task_id: Optional[List[TaskIdEnum5]] = Query(None, alias='taskId'),
    domain: Optional[List[str]] = ['state-roads'],
) -> MaintenanceTrackingLatestFeatureCollectionV1:
    """
    Road maintenance tracking routes latest points
    """
    pass


@app.get(
    '/api/maintenance/v1/tracking/routes/{id}',
    response_model=MaintenanceTrackingFeatureV1,
    tags=['Maintenance V1'],
)
def get_maintenance_tracking(id: int) -> MaintenanceTrackingFeatureV1:
    """
    Road maintenance tracking route with tracking id
    """
    pass


@app.get(
    '/api/maintenance/v1/tracking/tasks',
    response_model=List[MaintenanceTrackingTaskDtoV1],
    tags=['Maintenance V1'],
)
def get_maintenance_tracking_tasks() -> List[MaintenanceTrackingTaskDtoV1]:
    """
    Road maintenance tracking tasks
    """
    pass


@app.get('/api/tms/v1/sensors', response_model=TmsStationSensorsDtoV1, tags=['TMS V1'])
def tms_sensors(
    last_updated: Optional[bool] = Query(False, alias='lastUpdated')
) -> TmsStationSensorsDtoV1:
    """
    The static information of available sensors of TMS stations (Traffic Measurement System / LAM)
    """
    pass


@app.get(
    '/api/tms/v1/stations',
    response_model=TmsStationFeatureCollectionSimpleV1,
    tags=['TMS V1'],
)
def tms_stations(
    last_updated: Optional[bool] = Query(False, alias='lastUpdated'),
    state: Optional[RoadStationState] = None,
) -> TmsStationFeatureCollectionSimpleV1:
    """
    The static information of TMS stations (Traffic Measurement System / LAM)
    """
    pass


@app.get(
    '/api/tms/v1/stations/data', response_model=TmsStationsDataDtoV1, tags=['TMS V1']
)
def tms_data(
    last_updated: Optional[bool] = Query(False, alias='lastUpdated')
) -> TmsStationsDataDtoV1:
    """
    Current data of TMS stations (Traffic Measurement System / LAM)
    """
    pass


@app.get(
    '/api/tms/v1/stations/sensor-constants',
    response_model=TmsStationsSensorConstantsDataDtoV1,
    tags=['TMS V1'],
)
def tms_sensor_constants(
    last_updated: Optional[bool] = Query(False, alias='lastUpdated')
) -> TmsStationsSensorConstantsDataDtoV1:
    """
    Current sensor constants and values of TMS stations (Traffic Measurement System / LAM)
    """
    pass


@app.get(
    '/api/tms/v1/stations/{id}',
    response_model=TmsStationFeatureDetailedV1,
    tags=['TMS V1'],
)
def tms_station_by_road_station_id(id: int) -> TmsStationFeatureDetailedV1:
    """
    The static information of one TMS station (Traffic Measurement System / LAM)
    """
    pass


@app.get(
    '/api/tms/v1/stations/{id}/data',
    response_model=TmsStationDataDtoV1,
    tags=['TMS V1'],
)
def tms_data_by_id(id: int) -> TmsStationDataDtoV1:
    """
    Current data of one TMS station (Traffic Measurement System / LAM)
    """
    pass


@app.get(
    '/api/tms/v1/stations/{id}/sensor-constants',
    response_model=TmsStationSensorConstantDtoV1,
    tags=['TMS V1'],
)
def tms_sensor_constants_by_station_id(id: int) -> TmsStationSensorConstantDtoV1:
    """
    Current sensor constants and values of one TMS station (Traffic Measurement System / LAM)
    """
    pass


@app.get(
    '/api/traffic-message/v1/area-geometries',
    response_model=RegionGeometryFeatureCollectionV1,
    tags=['Traffic message V1'],
)
def area_location_regions(
    last_updated: Optional[bool] = Query(True, alias='lastUpdated'),
    include_geometry: Optional[bool] = Query(False, alias='includeGeometry'),
    effective_date: Optional[datetime] = Query(None, alias='effectiveDate'),
) -> RegionGeometryFeatureCollectionV1:
    """
    Traffic messages geometries for regions
    """
    pass


@app.get(
    '/api/traffic-message/v1/area-geometries/{locationCode}',
    response_model=RegionGeometryFeatureCollectionV1,
    tags=['Traffic message V1'],
)
def area_location_regions_1(
    last_updated: Optional[bool] = Query(False, alias='lastUpdated'),
    include_geometry: Optional[bool] = Query(False, alias='includeGeometry'),
    effective_date: Optional[datetime] = Query(None, alias='effectiveDate'),
    location_code: int = Path(..., alias='locationCode'),
) -> RegionGeometryFeatureCollectionV1:
    """
    Traffic messages geometries for regions
    """
    pass


@app.get(
    '/api/traffic-message/v1/locations',
    response_model=LocationFeatureCollectionV1,
    tags=['Traffic message V1'],
)
def locations(
    version: Optional[str] = 'latest',
    last_updated: Optional[bool] = Query(False, alias='lastUpdated'),
) -> LocationFeatureCollectionV1:
    """
    The static information of locations
    """
    pass


@app.get(
    '/api/traffic-message/v1/locations/types',
    response_model=LocationTypesDtoV1,
    tags=['Traffic message V1'],
)
def location_types(
    version: Optional[str] = 'latest',
    last_updated: Optional[bool] = Query(False, alias='lastUpdated'),
) -> LocationTypesDtoV1:
    """
    The static information of location types and locationsubtypes
    """
    pass


@app.get(
    '/api/traffic-message/v1/locations/versions',
    response_model=List[LocationVersionDtoV1],
    tags=['Traffic message V1'],
)
def location_versions() -> List[LocationVersionDtoV1]:
    """
    List available location versions
    """
    pass


@app.get(
    '/api/traffic-message/v1/locations/{id}',
    response_model=LocationFeatureV1,
    tags=['Traffic message V1'],
)
def location_by_id(
    version: Optional[str] = 'latest', id: int = ...
) -> LocationFeatureV1:
    """
    The static information of one location
    """
    pass


@app.get(
    '/api/traffic-message/v1/messages',
    response_model=TrafficAnnouncementFeatureCollectionV1,
    tags=['Traffic message V1'],
)
def traffic_message_simple(
    inactive_hours: Optional[int] = Query(0, alias='inactiveHours'),
    include_area_geometry: Optional[bool] = Query(False, alias='includeAreaGeometry'),
    situation_type: List[SituationTypeV1] = Query(..., alias='situationType'),
) -> TrafficAnnouncementFeatureCollectionV1:
    """
    Active traffic messages as simple JSON
    """
    pass


@app.get(
    '/api/traffic-message/v1/messages.datex2',
    response_model=D2LogicalModel,
    tags=['Traffic message V1'],
)
def traffic_message_datex2(
    inactive_hours: Optional[int] = Query(0, alias='inactiveHours'),
    situation_type: List[SituationTypeV1] = Query(..., alias='situationType'),
) -> D2LogicalModel:
    """
    Active traffic messages as Datex2
    """
    pass


@app.get(
    '/api/traffic-message/v1/messages/{situationId}',
    response_model=TrafficAnnouncementFeatureCollectionV1,
    tags=['Traffic message V1'],
)
def traffic_message_simple_by_situation_id(
    situation_id: str = Path(..., alias='situationId'),
    include_area_geometry: Optional[bool] = Query(False, alias='includeAreaGeometry'),
    latest: Optional[bool] = False,
) -> TrafficAnnouncementFeatureCollectionV1:
    """
    Traffic messages history by situation id as simple JSON
    """
    pass


@app.get(
    '/api/traffic-message/v1/messages/{situationId}.datex2',
    response_model=D2LogicalModel,
    tags=['Traffic message V1'],
)
def traffic_message_datex2_by_situation_id(
    situation_id: str = Path(..., alias='situationId'), latest: Optional[bool] = True
) -> D2LogicalModel:
    """
    Traffic messages by situationId as Datex2
    """
    pass


@app.get(
    '/api/variable-sign/v1/images/{text}',
    response_model=SvgModel,
    responses={'400': {'model': Empty}, '500': {'model': Empty}},
    tags=['Variable Sign V1'],
)
def get_api_variable_sign_v1_images_text(text: str) -> Union[SvgModel, Empty]:
    """
    Generate svg-image from given text
    """
    pass


@app.get(
    '/api/variable-sign/v1/signs',
    response_model=VariableSignFeatureCollectionV1,
    tags=['Variable Sign V1'],
)
def variable_signs(
    device_id: Optional[str] = Query(None, alias='deviceId')
) -> VariableSignFeatureCollectionV1:
    """
    Return the latest data of variable signs. If deviceId is given, latest data for that sign will be returned, otherwise return the latest data for each sign from the last 7 days.
    """
    pass


@app.get(
    '/api/variable-sign/v1/signs.datex2',
    response_model=XmlModel,
    tags=['Variable Sign V1'],
)
def get_api_variable_sign_v1_signs_datex2() -> XmlModel:
    """
    Return all variables signs as datex2
    """
    pass


@app.get(
    '/api/variable-sign/v1/signs/code-descriptions',
    response_model=VariableSignDescriptions,
    tags=['Variable Sign V1'],
)
def get_code_descriptions() -> VariableSignDescriptions:
    """
    Return all code descriptions.
    """
    pass


@app.get(
    '/api/variable-sign/v1/signs/history',
    response_model=List[TrafficSignHistoryV1],
    tags=['Variable Sign V1'],
)
def variable_sign_history(
    device_id: str = Query(..., alias='deviceId'),
    effective_date: Optional[datetime] = Query(None, alias='effectiveDate'),
) -> List[TrafficSignHistoryV1]:
    """
    Return the history of variable sign data
    """
    pass


@app.get(
    '/api/variable-sign/v1/signs/{deviceId}',
    response_model=VariableSignFeatureCollectionV1,
    tags=['Variable Sign V1'],
)
def variable_sign_by_path(
    device_id: str = Path(..., alias='deviceId')
) -> VariableSignFeatureCollectionV1:
    """
    Return the latest value of a variable sign
    """
    pass


@app.get(
    '/api/weather/v1/forecast-sections',
    response_model=ForecastSectionFeatureCollectionV1,
    tags=['Weather V1'],
)
def forecast_sections(
    last_updated: Optional[bool] = Query(False, alias='lastUpdated'),
    simplified: Optional[bool] = False,
    road_number: Optional[int] = Query(None, alias='roadNumber'),
    x_min: Optional[confloat(ge=19.0, le=32.0)] = Query(19, alias='xMin'),
    y_min: Optional[confloat(ge=59.0, le=72.0)] = Query(59, alias='yMin'),
    x_max: Optional[confloat(ge=19.0, le=32.0)] = Query(32, alias='xMax'),
    y_max: Optional[confloat(ge=59.0, le=72.0)] = Query(72, alias='yMax'),
) -> ForecastSectionFeatureCollectionV1:
    """
    The static information of weather forecast sections
    """
    pass


@app.get(
    '/api/weather/v1/forecast-sections-simple',
    response_model=ForecastSectionFeatureCollectionSimpleV1,
    tags=['Weather V1'],
)
def forecast_sections_simple(
    last_updated: Optional[bool] = Query(False, alias='lastUpdated'),
    road_number: Optional[int] = Query(None, alias='roadNumber'),
    x_min: Optional[confloat(ge=19.0, le=32.0)] = Query(19, alias='xMin'),
    y_min: Optional[confloat(ge=59.0, le=72.0)] = Query(59, alias='yMin'),
    x_max: Optional[confloat(ge=19.0, le=32.0)] = Query(32, alias='xMax'),
    y_max: Optional[confloat(ge=59.0, le=72.0)] = Query(72, alias='yMax'),
) -> ForecastSectionFeatureCollectionSimpleV1:
    """
    The static information of simple weather forecast sections
    """
    pass


@app.get(
    '/api/weather/v1/forecast-sections-simple/forecasts',
    response_model=ForecastSectionsWeatherDtoV1,
    tags=['Weather V1'],
)
def forecast_sections_simple_forecasts(
    last_updated: Optional[bool] = Query(False, alias='lastUpdated'),
    road_number: Optional[int] = Query(None, alias='roadNumber'),
    x_min: Optional[confloat(ge=19.0, le=32.0)] = Query(19, alias='xMin'),
    y_min: Optional[confloat(ge=59.0, le=72.0)] = Query(59, alias='yMin'),
    x_max: Optional[confloat(ge=19.0, le=32.0)] = Query(32, alias='xMax'),
    y_max: Optional[confloat(ge=59.0, le=72.0)] = Query(72, alias='yMax'),
) -> ForecastSectionsWeatherDtoV1:
    """
    Current data of simple weather forecast sections
    """
    pass


@app.get(
    '/api/weather/v1/forecast-sections-simple/{id}',
    response_model=ForecastSectionFeatureSimpleV1,
    tags=['Weather V1'],
)
def forecast_section_simple_by_id(id: str) -> ForecastSectionFeatureSimpleV1:
    """
    The static information of simple weather forecast sections
    """
    pass


@app.get(
    '/api/weather/v1/forecast-sections-simple/{id}/forecasts',
    response_model=ForecastSectionWeatherDtoV1,
    tags=['Weather V1'],
)
def forecast_section_simple_forecasts_by_id(id: str) -> ForecastSectionWeatherDtoV1:
    """
    Current data of simple weather forecast sections
    """
    pass


@app.get(
    '/api/weather/v1/forecast-sections/forecasts',
    response_model=ForecastSectionsWeatherDtoV1,
    tags=['Weather V1'],
)
def forecast_sections_forecasts(
    last_updated: Optional[bool] = Query(False, alias='lastUpdated'),
    road_number: Optional[int] = Query(None, alias='roadNumber'),
    x_min: Optional[confloat(ge=19.0, le=32.0)] = Query(19, alias='xMin'),
    y_min: Optional[confloat(ge=59.0, le=72.0)] = Query(59, alias='yMin'),
    x_max: Optional[confloat(ge=19.0, le=32.0)] = Query(32, alias='xMax'),
    y_max: Optional[confloat(ge=59.0, le=72.0)] = Query(72, alias='yMax'),
) -> ForecastSectionsWeatherDtoV1:
    """
    Current data of detailed weather forecast sections
    """
    pass


@app.get(
    '/api/weather/v1/forecast-sections/{id}',
    response_model=ForecastSectionFeatureV1,
    tags=['Weather V1'],
)
def forecast_section_by_id(
    simplified: Optional[bool] = False, id: str = ...
) -> ForecastSectionFeatureV1:
    """
    The static information of weather forecast sections
    """
    pass


@app.get(
    '/api/weather/v1/forecast-sections/{id}/forecasts',
    response_model=ForecastSectionWeatherDtoV1,
    tags=['Weather V1'],
)
def forecast_section_forecasts_by_id(id: str) -> ForecastSectionWeatherDtoV1:
    """
    Current data of weather forecast sections
    """
    pass


@app.get(
    '/api/weather/v1/sensors',
    response_model=WeatherStationSensorsDtoV1,
    tags=['Weather V1'],
)
def weather_sensors(
    last_updated: Optional[bool] = Query(False, alias='lastUpdated')
) -> WeatherStationSensorsDtoV1:
    """
    The static information of available sensors of weather stations
    """
    pass


@app.get(
    '/api/weather/v1/stations',
    response_model=WeatherStationFeatureCollectionSimpleV1,
    tags=['Weather V1'],
)
def weather_stations(
    last_updated: Optional[bool] = Query(False, alias='lastUpdated'),
    state: Optional[RoadStationState] = None,
) -> WeatherStationFeatureCollectionSimpleV1:
    """
    The static information of weather stations
    """
    pass


@app.get(
    '/api/weather/v1/stations/data',
    response_model=WeatherStationsDataDtoV1,
    tags=['Weather V1'],
)
def weather_data(
    last_updated: Optional[bool] = Query(False, alias='lastUpdated')
) -> WeatherStationsDataDtoV1:
    """
    Current data of weather stations
    """
    pass


@app.get(
    '/api/weather/v1/stations/{id}',
    response_model=WeatherStationFeatureDetailedV1,
    tags=['Weather V1'],
)
def weather_station_by_road_station_id(id: int) -> WeatherStationFeatureDetailedV1:
    """
    The static information of one weather station
    """
    pass


@app.get(
    '/api/weather/v1/stations/{id}/data',
    response_model=WeatherStationDataDtoV1,
    tags=['Weather V1'],
)
def weather_data_by_id(id: int) -> WeatherStationDataDtoV1:
    """
    Current data of one weather station
    """
    pass


@app.get(
    '/api/weathercam/v1/publicities/changes',
    response_model=WeathercamStationsPresetsPublicityHistoryV1,
    tags=['Weathercam V1'],
)
def weathercam_preset_publicity_changes_after(
    after: Optional[datetime] = None,
) -> WeathercamStationsPresetsPublicityHistoryV1:
    """
    Weathercam presets publicity changes after given time. Result is in ascending order by presetId and lastModified -fields.
    """
    pass


@app.get(
    '/api/weathercam/v1/stations',
    response_model=WeathercamStationFeatureCollectionSimpleV1,
    tags=['Weathercam V1'],
)
def weathercam_stations(
    last_updated: Optional[bool] = Query(False, alias='lastUpdated')
) -> WeathercamStationFeatureCollectionSimpleV1:
    """
    The static information of weather camera stations
    """
    pass


@app.get(
    '/api/weathercam/v1/stations/data',
    response_model=WeathercamStationsDataV1,
    tags=['Weathercam V1'],
)
def weathercams_datas(
    last_updated: Optional[bool] = Query(False, alias='lastUpdated')
) -> WeathercamStationsDataV1:
    """
    Current data of weathercams
    """
    pass


@app.get(
    '/api/weathercam/v1/stations/history',
    response_model=CameraHistory,
    tags=['Weathercam V1'],
)
def get_weathercams_presets_history() -> CameraHistory:
    """
    Weathercams presets history for all cameras
    """
    pass


@app.get(
    '/api/weathercam/v1/stations/{id}',
    response_model=WeathercamStationFeatureV1Detailed,
    tags=['Weathercam V1'],
)
def weathercam_station(id: str) -> WeathercamStationFeatureV1Detailed:
    """
    The static information of weather camera station
    """
    pass


@app.get(
    '/api/weathercam/v1/stations/{id}/data',
    response_model=WeathercamStationDataV1,
    tags=['Weathercam V1'],
)
def weathercam_datas_by_station_id(id: str) -> WeathercamStationDataV1:
    """
    Current data of weathercam
    """
    pass


@app.get(
    '/api/weathercam/v1/stations/{id}/history',
    response_model=PresetHistory,
    tags=['Weathercam V1'],
)
def get_weathercam_presets_history_by_id(id: str) -> PresetHistory:
    """
    Weathercam presets history for given camera
    """
    pass
