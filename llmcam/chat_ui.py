"""chat UI implemented in fastHTML"""

# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/05_chat_ui.ipynb.

# %% auto 0
__all__ = ['tools', 'hdrs', 'app', 'scroll_script', 'extract_live_info', 'extract_parameter_comments', 'param_converter',
           'tool_schema', 'fn_name', 'fn_args', 'fn_exec', 'fn_result_content', 'generate_response', 'ChatMessage',
           'ChatInput', 'ActionButton', 'ActionPanel', 'index', 'send', 'llmcam_chatbot']

# %% ../nbs/05_chat_ui.ipynb 4
# Importing openai and our custom functions
import openai
import json
import ast
import inspect

from typing import Optional, Union
from types import NoneType
from .ytlive import capture_youtube_live_frame
from .gpt4v import ask_gpt4v

# %% ../nbs/05_chat_ui.ipynb 6
def extract_live_info(
        link: Optional[str] = None  # YouTube Live link
    ) -> dict:  # The extracted information
    """Extract information from a YouTube Live"""
    if link:
        image = capture_youtube_live_frame(link)
    else:
        image = capture_youtube_live_frame()
    
    return ask_gpt4v(image)

# %% ../nbs/05_chat_ui.ipynb 8
# Extract parameter comments from the function
def extract_parameter_comments(func):
    """Extract comments for function arguments"""
    # Get the source code of the function
    source = inspect.getsource(func)
    # Parse the source code into an AST
    tree = ast.parse(source)
    
    # Extract comments for function arguments
    comments = {}
    for node in ast.walk(tree):
        if isinstance(node, ast.FunctionDef) and node.name == func.__name__:
            # Get arguments and comments in the function
            for arg in node.args.args:
                arg_name = arg.arg
                # Check if there's an inline comment associated with the argument
                if arg.end_lineno and arg.col_offset:
                    # Loop through the source code lines to find the comment
                    lines = source.splitlines()
                    for line in lines:
                        if line.strip().startswith(f"{arg_name}:") and "#" in line:
                            comment = line.split("#")[1].strip()
                            comments[arg_name] = comment
    return comments

# %% ../nbs/05_chat_ui.ipynb 13
def param_converter(
        param_type,  # The type of the parameter
        description  # The description of the parameter
    ) -> dict:  # The converted parameter
    """Convert parameter types to acceptable types for tool schema"""
    simple_types = {
        str: "string",
        int: "number",
        float: "number",
        bool: "boolean",
    }
    if param_type in simple_types:
        return { "type": simple_types[param_type], "description": description }
    elif param_type == NoneType:
        return { "type": "null", "description": "A default value will be automatically used." }
    
    if hasattr(param_type, '__origin__') and param_type.__origin__ == Union:
        # Recursively convert the types
        descriptions = description.split(" or ")
        subtypes = param_type.__args__
        if len(subtypes) > len(descriptions):
            descriptions = descriptions + ["A description is not provided"] * (len(subtypes) - len(descriptions))

        return {
            "anyOf": [param_converter(subtype, desc) for subtype, desc in zip(subtypes, descriptions)]
        }
    return { "type": "string", "description": description }

# %% ../nbs/05_chat_ui.ipynb 17
def tool_schema(func):
    """Automatically generate a schema from its parameters and docstring"""
    # Extract function name, docstring, and parameters
    func_name = func.__name__
    func_description = func.__doc__ or "No description provided."
    signature = inspect.signature(func)
    
    # Create parameters schema
    parameters_schema = {
        "type": "object",
        "properties": {},
        "required": []
    }
    
    # Populate properties and required fields
    param_comments = extract_parameter_comments(func)
    for param_name, param in signature.parameters.items():
        param_type = param.annotation if param.annotation != inspect._empty else str
        
        # Add parameter to schema
        parameters_schema["properties"][param_name] = param_converter(
            param_type, 
            param_comments.get(param_name, "No description provided.")
        )
        
        # Mark as required if no default
        if param.default == inspect.Parameter.empty:
            parameters_schema["required"].append(param_name)
    
    # Build final tool schema
    tool_schema = [
        {
            "type": "function",
            "function": {
                "name": func_name,
                "description": func_description,
                "parameters": parameters_schema,
            }
        }
    ]
    return tool_schema

# %% ../nbs/05_chat_ui.ipynb 18
tools = tool_schema(extract_live_info)

# %% ../nbs/05_chat_ui.ipynb 21
# Support functions to handle tool response,where res == response.choices[0].message
def fn_name(res): return res.tool_calls[0].function.name
def fn_args(res): return json.loads(res.tool_calls[0].function.arguments)    
def fn_exec(res): return globals().get(fn_name(res))(**fn_args(res))
def fn_result_content(res):
    """Create a content containing the result of the function call"""
    content = dict()
    content.update(fn_args(res))
    content.update({fn_name(res): fn_exec(res)})
    return json.dumps(content)

# %% ../nbs/05_chat_ui.ipynb 23
def generate_response(
        message: str,  # New message frorm the user
        history : list,  # Previous messages
    ) -> list:  # The responses of GPT model
    """Generate a response from the messages"""
    responses = []

    def complete(role, content, tool_call_id=None):
        "Send completion request with messages, and save the response in messages again"
        responses.append({
            "role":role, 
            "content":content, 
            "tool_call_id":tool_call_id
        })
        response = openai.chat.completions.create(
            model="gpt-4o", 
            messages=history + responses, 
            tools=tools
        )
        res = response.choices[0].message
        responses.append(res.to_dict())
        if res.to_dict().get('tool_calls'):
            complete(role="tool", content=fn_result_content(res), tool_call_id=res.tool_calls[0].id)

    complete("user", message)

    return responses

# %% ../nbs/05_chat_ui.ipynb 26
import uvicorn
import importlib.util
from fasthtml.common import *

# %% ../nbs/05_chat_ui.ipynb 27
# Set up the app, including daisyui and tailwind for the chat component
hdrs = (picolink, Script(src="https://cdn.tailwindcss.com"),
        Link(rel="stylesheet", href="https://cdn.jsdelivr.net/npm/daisyui@4.11.1/dist/full.min.css"),
        MarkdownJS(), HighlightJS(langs=['python', 'javascript', 'html', 'css']))
app = FastHTML(hdrs=hdrs)

# %% ../nbs/05_chat_ui.ipynb 29
# Chat message component (renders a chat bubble)
def ChatMessage(
        msg: str,  # Message to display
        user: bool  # Whether the message is from the user or assistant
    ):  # Returns a Div containing the chat bubble
    # Set class to change displayed style of bubble
    bubble_class = "chat-bubble-primary" if user else 'chat-bubble-secondary'
    chat_class = "chat-end" if user else 'chat-start'
    return  Div(cls=f"chat {chat_class}")(
                Div('User' if user else 'Assistant', cls="chat-header"),
                Div(
                    msg,
                    cls=f"chat-bubble {bubble_class} marked px-6 py-4", 
                    style=f"background-color: {'#038a5e' if user else '#025238'}; color: {'black' if user else 'white'};"),
                Hidden(msg, name="messages"),  # Hidden field for submitting past messages to form
                Hidden("user" if user else "assistant", name="roles")  # Hidden field for submitting corresponding owners
            )

# %% ../nbs/05_chat_ui.ipynb 32
# The input field for the user message. Also used to clear the
# input field after sending a message via an OOB swap
def ChatInput():  # Returns an input field for the user message
    return Input(name='msg', id='msg-input', placeholder="Type a message",
                 cls="input input-bordered w-full rounded-l-2xl bg-stone-800", 
                 hx_swap_oob='true'  # Re-render the element to remove submitted message
                )

# %% ../nbs/05_chat_ui.ipynb 35
def ActionButton(
        content: str  # Text to display on the button
    ):  # Returns a button with the given content

    return Form(
        hx_post="/",
        hx_target="#chatlist",
        hx_swap="beforeend",  # Location: just before the end of element
    )(
        Hidden(content, name="msg"),
        Button(content, cls="btn btn-secondary")
    )

def ActionPanel():  # Returns a panel of action buttons
    return Div(
        ActionButton("Introduce your model GPT-4o"),
        ActionButton("Extract information from a YouTube Live"),
        cls="flex flex-row h-fit px-24 gap-4 pt-4"
    )

# %% ../nbs/05_chat_ui.ipynb 40
scroll_script = Script("""
  // Function to scroll to the bottom of an element
  function scrollToBottom(element) {
    element.scrollTop = element.scrollHeight;
  }

  // Reference the expanding element
  const expandingElement = document.getElementById('chatlist');

  // Observe changes to the element's content and scroll down automatically
  const observer = new MutationObserver(() => {
    scrollToBottom(expandingElement);
  });

  // Start observing the expanding element for changes
  observer.observe(expandingElement, { childList: true, subtree: true });
""")

# %% ../nbs/05_chat_ui.ipynb 41
@app.get('/')
def index():
    sidebar = Div(
        H1("Conversations"),
        cls="w-[30vw] bg-stone-800"
    )
    page =  Div(cls="w-full flex flex-col p-0")(
        ActionPanel(),
        Form(
            hx_post="/",  # Operation: some POST endpoint with function `send` 
            hx_target="#chatlist",  # Target: element with ID 'chatlist'
            hx_swap="beforeend",  # Location: just before the end of element
            cls="w-full flex flex-col px-24 h-[90vh]"
        )(
            # The chat list
            Div(id="chatlist", cls="chat-box overflow-y-auto flex-1 w-full mt-10")(
                # One initial message from AI assistant
                ChatMessage("Hello! I'm a chatbot. How can I help you today?", False),
            ),
            # Input form
            Div(cls="h-fit mb-5 mt-5 flex space-x-2 mt-2")(
                Group(
                    ChatInput(), 
                    Button("Send", cls="btn btn-primary rounded-r-2xl", style="background-color: #03fcad;"))
            ),
            scroll_script
        )   
    )
    return Main(
        sidebar,
        page, 
        data_theme="forest", 
        cls="h-[100vh] w-full relative flex flex-row items-stretch overflow-hidden transition-colors z-0 p-0",)

# %% ../nbs/05_chat_ui.ipynb 43
# Handle the form submission
@app.post('/')
def send(msg: str, messages: list[str] = None, roles: list[str] = None):
    if not messages: messages = []
    if not roles: roles = []

    history = [ {"role": role, "content": message} for role, message in zip(roles, messages) ]
    
    # Add the user's message to the chat history
    responses = generate_response(msg, history)
    chat_messages = [
        ChatMessage(res['content'], res['role'] == 'user') for res in responses if 'content' in res \
            if res['role'] in ['user', 'assistant'] and res['content'] is not None
    ]
    
    return (*chat_messages,
            ChatInput()) # And clear the input field via an OOB swap

# %% ../nbs/05_chat_ui.ipynb 45
def llmcam_chatbot(
        package_name="ninjalabo.llmcam",  # The installed package name
        module_name="chat_ui",  # The module containing the FastAPI app
        app_variable="app",  # The FastAPI app variable name
        host="0.0.0.0",  # The host to listen on
        port=5001,  # The port to listen on
        **uvicorn_kwargs  # Additional keyword arguments for uvicorn
    ):
    "Find and run the FastAPI app in the specified module within the given package."
    # Construct the full module path (e.g., 'llmcam.chat_ui')
    full_module_path = f"{package_name.split('.')[-1]}.{module_name}"

    # Check if the module exists in the installed package
    try:
        spec = importlib.util.find_spec(full_module_path)
        if spec is None:
            print(f"Module '{full_module_path}' not found in package '{package_name}'.")
            return
        # Dynamically run the Uvicorn server
        uvicorn.run(f"{full_module_path}:{app_variable}", host=host, port=port, **uvicorn_kwargs)
    except Exception as e:
        print(f"Error running the app: {e}")
