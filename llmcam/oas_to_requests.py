# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/oas_to_requests.ipynb.

# %% auto 0
__all__ = ['extract_refs']

# %% ../nbs/oas_to_requests.ipynb 3
import requests
# from openapi_schema_pydantic import OpenAPI
from pprint import pprint
import json
import yaml
import copy

# %% ../nbs/oas_to_requests.ipynb 8
def extract_refs(
        oas: dict  # The OpenAPI schema
    ) -> dict:  # The extracted references (flattened)
    refs = copy.deepcopy(oas)
    refs_list = set()
    refs_locations = {}
    refs_dependencies = {}

    # Traverse the components section of the spec
    for section, items in refs["components"].items():
        for item in items:
            refs_list.add(f"components/{section}/{item}")
            refs_locations[f"components/{section}/{item}"] = []
            refs_dependencies[f"components/{section}/{item}"] = set()
    
    # Initialize the clean_refs set
    clean_refs = refs_list.copy()

    # Traverse the spec and extract the references
    def traverse_location(obj, path=""):
        for key, value in obj.items():
            if key == "$ref":
                # Determine the root of the reference and remove it from the clean_refs set
                ref_root = "/".join(path.split("/")[:3])
                clean_refs.discard(ref_root)

                # Extract the sub reference and add the current path to the list of locations
                sub_ref = value[2:]
                refs_locations[sub_ref].append(path)

                # Add the sub reference to the dependencies of the current reference
                refs_dependencies[ref_root].add(sub_ref)

            elif isinstance(value, dict):
                # Recursively traverse the object
                traverse_location(value, f"{path}/{key}")

    traverse_location(refs["components"], "components")

    # Attach the reference objects to the locations
    def attach_clean_refs():
        for ref in clean_refs:
            # Extract the reference object
            ref_obj = refs
            for part in ref.split("/"):
                ref_obj = ref_obj[part]

            # Extract the locations where the reference is used
            locations = refs_locations[ref]

            # Attach the reference object to the locations
            for location in locations:
                location_parts = location.split("/")

                obj = refs
                prev = None
                for part in location_parts:
                    prev = obj
                    obj = obj[part]

                prev[location_parts[-1]] = ref_obj

            # Remove the reference from the dependencies
            for dependency in refs_dependencies:
                refs_dependencies[dependency].discard(ref)

    # Check if there are any clean references
    def check_clean_refs():
        clean_refs = set()
        for ref, dependencies in refs_dependencies.items():
            if len(dependencies) == 0:
                clean_refs.add(ref)
        return clean_refs
    
    # Iterate until all references are attached or no progress is made
    prev_nof_clean = None
    while len(clean_refs) < len(refs_list) and prev_nof_clean != len(clean_refs):
        prev_nof_clean = len(clean_refs)
        attach_clean_refs()
        clean_refs = check_clean_refs()

    # Flatten the references
    flatten_refs = {}
    for section, items in refs["components"].items():
        for item in items:
            flatten_refs[f"#/components/{section}/{item}"] = refs["components"][section][item]

    return flatten_refs

# %% ../nbs/oas_to_requests.ipynb 13
def __generate_request_by_operation_id(oas, operation_id, parameters=None, data=None):
    # Search for the operation by `operationId`
    for path, path_item in oas.paths.items():
        for method, operation in path_item.dict().items():
            if operation and operation.get("operationId") == operation_id:
                url = f"{BASE_URL}{path}"
                headers = {"Content-Type": "application/json"}
                
                # Determine request body: use `data` if provided; otherwise, generate from schema
                request_body = data or get_request_body_from_schema(operation, oas)

                # Make the HTTP request dynamically
                response = requests.request(method.upper(), url, params=parameters, json=request_body, headers=headers)
                print(url, request_body)
                return response.json() if response.status_code in (200, 201) else response.status_code
    print(f"OperationId '{operation_id}' not found.")
    return None
