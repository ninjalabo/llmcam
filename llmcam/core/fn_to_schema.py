"""Python module to automatically convert a given Python function into tool schema appropriate for function calling"""

# AUTOGENERATED! DO NOT EDIT! File to edit: ../../nbs/01_Core/02_fn_to_schema.ipynb.

# %% auto 0
__all__ = ['extract_parameter_comments', 'param_converter', 'function_schema']

# %% ../../nbs/01_Core/02_fn_to_schema.ipynb 7
import ast
import inspect

from types import NoneType
from typing import Optional, Union, Callable, Literal,  Tuple

# %% ../../nbs/01_Core/02_fn_to_schema.ipynb 9
# Extract parameter comments from the function
def extract_parameter_comments(
        func: Callable  # Function to extract comments from
    ) -> dict[str, str]:  # Dictionary with parameter comments
    """Extract comments for function arguments"""
    # Get the source code of the function
    source = inspect.getsource(func)
    # Parse the source code into an AST
    tree = ast.parse(source)
    
    # Extract comments for function arguments
    comments = {}
    for node in ast.walk(tree):
        if isinstance(node, ast.FunctionDef) and node.name == func.__name__:
            # Get arguments and comments in the function
            for arg in node.args.args:
                arg_name = arg.arg
                # Check if there's an inline comment associated with the argument
                if arg.end_lineno and arg.col_offset:
                    # Loop through the source code lines to find the comment
                    lines = source.splitlines()
                    for line in lines:
                        if line.strip().startswith(f"{arg_name}:") and "#" in line:
                            comment = line.split("#")[1].strip()
                            comments[arg_name] = comment
    return comments

# %% ../../nbs/01_Core/02_fn_to_schema.ipynb 15
def param_converter(
        param_type,  # The type of the parameter
        description  # The description of the parameter
    ) -> dict:  # The converted parameter
    """Convert Python parameter types to acceptable types for tool schema"""
    # Use direct mapping for simple Python types to OpenAPI types
    simple_types = {
        str: "string",
        int: "number",
        float: "number",
        bool: "boolean",
    }
    if param_type in simple_types:
        return { "type": simple_types[param_type], "description": description }
    
    # For NoneType, set the type to null and provide a suitable description
    elif param_type == NoneType:
        return { "type": "null", "description": "A default value will be automatically used." }
    
    # For list types, set the type to array and provide the item type
    if param_type == list or getattr(param_type, "__origin__", None) == list:
        item_type = param_type.__args__[0] if hasattr(param_type, "__args__") and param_type.__args__ else str
        return {
            "type": "array",
            "description": description,
            "items": { "type": param_converter(item_type, description)["type"] }
        }
    
    # For union types, set the type to anyOf and provide the subtypes
    # Note: Optional[X] is represented as Union[X, None] in Python
    if hasattr(param_type, '__origin__') and param_type.__origin__ == Union:
        # Recursively convert the types
        descriptions = description.split(" or ")
        subtypes = param_type.__args__
        if len(subtypes) > len(descriptions):
            descriptions = descriptions + ["A description is not provided"] * (len(subtypes) - len(descriptions))

        return {
            "anyOf": [param_converter(subtype, desc) for subtype, desc in zip(subtypes, descriptions)]
        }
    
    # For any other types, set the type to string and pass the description
    return { "type": "string", "description": description }

# %% ../../nbs/01_Core/02_fn_to_schema.ipynb 20
def function_schema(
        func: Callable,  # The function to generate the schema for
        service_name: Optional[str] = None,  # The name of the service
        fixup: Optional[Callable] = None,  # A function to fix up the schema
        **kwargs  # Additional keyword arguments as metadata
    ) -> dict:  # The generated tool schema
    """Generate a schema from function using its parameters and docstring"""
    # Extract function name, docstring, and parameters
    func_name = func.__name__
    func_description = func.__doc__ or "No description provided."
    func_module = func.__module__
    signature = inspect.signature(func)
    
    # Create parameters schema
    parameters_schema = {
        "type": "object",
        "properties": {},
        "required": []
    }
    
    # Populate properties and required fields
    param_comments = extract_parameter_comments(func)
    for param_name, param in signature.parameters.items():
        param_type = param.annotation if param.annotation != inspect._empty else str
        
        # Add parameter to schema
        parameters_schema["properties"][param_name] = param_converter(
            param_type, 
            param_comments.get(param_name, "No description provided.")
        )
        
        # Mark as required if no default
        if param.default == inspect.Parameter.empty:
            parameters_schema["required"].append(param_name)
    
    # Build final tool schema
    tool_schema = {
        "type": "function",
        "function": {
            "name": func_name,
            "description": func_description,
            "parameters": parameters_schema,
            "metadata": {
                "module": func_module,
                "service": service_name or func_module,
                **kwargs
            }
        }
    }

    # Apply fixup function if provided
    if fixup: tool_schema['function']['fixup'] = f"{fixup.__module__}.{fixup.__name__}"
    
    return tool_schema
