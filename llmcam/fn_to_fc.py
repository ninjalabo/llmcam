"""python module to convert a given Fn into FC automatically"""

# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/06_fn_to_fc.ipynb.

# %% auto 0
__all__ = ['YTLiveTools', 'capture_youtube_live_frame_and_save', 'ask_gpt4v_about_image_file', 'extract_parameter_comments',
           'param_converter', 'tool_schema', 'fn_name', 'fn_args', 'fn_metadata', 'fn_exec', 'fn_result_content',
           'print_msg', 'print_msgs', 'form_msg', 'form_msgs', 'complete']

# %% ../nbs/06_fn_to_fc.ipynb 3
# Importing openai and our custom functions
import openai
import json
import ast
import inspect
import importlib
import warnings

from typing import Optional, Union, Callable, Literal,  Tuple
from types import NoneType
from .ytlive import YTLive, NHsta
from .gpt4v import ask_gpt4v

import textwrap
from colorama import Fore, Back, Style

# %% ../nbs/06_fn_to_fc.ipynb 7
def capture_youtube_live_frame_and_save(
        link: Optional[str] = None,  # YouTube Live link
        place: Optional[str] = None,  # Location of live image
    ) -> str:  # Path to the saved image
    """Capture a jpeg file from YouTube Live and save in data directory"""
    if link is not None:
        live = YTLive(url=link, place=place)
    
    else:
        live = NHsta()
    return str(live())

# %% ../nbs/06_fn_to_fc.ipynb 9
def ask_gpt4v_about_image_file(
        path:str  # Path to the image file
    ) -> str:  # JSON string with quantitative information
    """Tell all about quantitative information from a given image file"""
    info = ask_gpt4v(path)
    return json.dumps(info)

# %% ../nbs/06_fn_to_fc.ipynb 13
# Extract parameter comments from the function
def extract_parameter_comments(
        func: Callable  # Function to extract comments from
    ) -> dict[str, str]:  # Dictionary with parameter comments
    """Extract comments for function arguments"""
    # Get the source code of the function
    source = inspect.getsource(func)
    # Parse the source code into an AST
    tree = ast.parse(source)
    
    # Extract comments for function arguments
    comments = {}
    for node in ast.walk(tree):
        if isinstance(node, ast.FunctionDef) and node.name == func.__name__:
            # Get arguments and comments in the function
            for arg in node.args.args:
                arg_name = arg.arg
                # Check if there's an inline comment associated with the argument
                if arg.end_lineno and arg.col_offset:
                    # Loop through the source code lines to find the comment
                    lines = source.splitlines()
                    for line in lines:
                        if line.strip().startswith(f"{arg_name}:") and "#" in line:
                            comment = line.split("#")[1].strip()
                            comments[arg_name] = comment
    return comments

# %% ../nbs/06_fn_to_fc.ipynb 19
def param_converter(
        param_type,  # The type of the parameter
        description  # The description of the parameter
    ) -> dict:  # The converted parameter
    """Convert Python parameter types to acceptable types for tool schema"""
    simple_types = {
        str: "string",
        int: "number",
        float: "number",
        bool: "boolean",
    }
    if param_type in simple_types:
        return { "type": simple_types[param_type], "description": description }
    elif param_type == NoneType:
        return { "type": "null", "description": "A default value will be automatically used." }
    
    if param_type == list or getattr(param_type, "__origin__", None) == list:
        item_type = param_type.__args__[0] if hasattr(param_type, "__args__") and param_type.__args__ else str
        return {
            "type": "array",
            "description": description,
            "items": { "type": param_converter(item_type, description)["type"] }
        }
    
    if hasattr(param_type, '__origin__') and param_type.__origin__ == Union:
        # Recursively convert the types
        descriptions = description.split(" or ")
        subtypes = param_type.__args__
        if len(subtypes) > len(descriptions):
            descriptions = descriptions + ["A description is not provided"] * (len(subtypes) - len(descriptions))

        return {
            "anyOf": [param_converter(subtype, desc) for subtype, desc in zip(subtypes, descriptions)]
        }
    return { "type": "string", "description": description }

# %% ../nbs/06_fn_to_fc.ipynb 24
def tool_schema(
        func: Callable,  # The function to generate the schema for
        service_name: Optional[str] = None,  # The name of the service
    ) -> dict:  # The generated tool schema
    """Automatically generate a schema from its parameters and docstring"""
    # Extract function name, docstring, and parameters
    func_name = func.__name__
    func_description = func.__doc__ or "No description provided."
    func_module = func.__module__
    signature = inspect.signature(func)
    
    # Create parameters schema
    parameters_schema = {
        "type": "object",
        "properties": {},
        "required": []
    }
    
    # Populate properties and required fields
    param_comments = extract_parameter_comments(func)
    for param_name, param in signature.parameters.items():
        param_type = param.annotation if param.annotation != inspect._empty else str
        
        # Add parameter to schema
        parameters_schema["properties"][param_name] = param_converter(
            param_type, 
            param_comments.get(param_name, "No description provided.")
        )
        
        # Mark as required if no default
        if param.default == inspect.Parameter.empty:
            parameters_schema["required"].append(param_name)
    
    # Build final tool schema
    tool_schema = {
        "type": "function",
        "function": {
            "name": func_name,
            "description": func_description,
            "parameters": parameters_schema,
            "metadata": {
                "module": func_module,
                "service": service_name or func_module
            }
        }
    }
    
    return tool_schema

# %% ../nbs/06_fn_to_fc.ipynb 26
# Environmental setting up
YTLiveTools = [tool_schema(fn) for fn in (capture_youtube_live_frame_and_save, ask_gpt4v_about_image_file)]

# %% ../nbs/06_fn_to_fc.ipynb 30
# Support functions to handle tool response,where call == response.choices[0].message.tool_calls[i]
def fn_name(call): return call["function"]["name"]
def fn_args(call): return json.loads(call["function"]["arguments"])
def fn_metadata(tool): return tool["function"]["metadata"]

def fn_exec(call, tools=[]):
    """Execute the function call"""
    for tool in tools:
        # Check if the function name matches
        if call['function']['name'] != tool['function']['name']:
            continue

        # Execute the function by dynamically importing the module
        try:
            module_path = tool['function']['metadata']['module']
            module = importlib.import_module(module_path)
            fn = getattr(module, fn_name(call))
            return fn(**fn_args(call))
        
        # If the function is not found, try to fix it
        except Exception as e:
            if not 'fixup' in tool['function']:
                continue
            module_path, fn_path = tool['function']['fixup'].rsplit('.', 1)
            fn = getattr(importlib.import_module(module_path), fn_path)
            return fn(fn_name(call), **fn_metadata(tool), **fn_args(call))

def fn_result_content(call, tools=[]):
    """Create a content containing the result of the function call"""
    content = dict()
    content.update(fn_args(call))
    content.update({fn_name(call): fn_exec(call, tools)})
    return json.dumps(content)

# %% ../nbs/06_fn_to_fc.ipynb 31
def print_msg(msg):
    who = msg['role'].capitalize()
    who = (Fore.RED if who in "System" else Fore.GREEN if who in "User" else Fore.BLUE if who in "Assistant" else Fore.CYAN) + who
    who = Back.YELLOW + who
    print(Style.BRIGHT + Fore.RED + f">> {who}:" + Style.RESET_ALL)
    try:
        print(textwrap.fill(msg["content"], 100))
    except:
        print(msg)

def print_msgs(msgs, skip_tools=True):
    for msg in msgs:
        if skip_tools and 'tool_calls' in msg.keys() or 'tool_call_id' in msg.keys():
            continue
        print_msg(msg)

def form_msg(
    role: Literal["system", "user", "assistant", "tool"],  # The role of the message sender
    content: str,  # The content of the message
    tool_call_id: Optional[str] = None,  # The ID of the tool call (if role == "tool")
):
    """Create a message for the conversation"""
    msg = {
        "role": role,
        "content": content
    }
    if role == "tool":
        msg["tool_call_id"] = tool_call_id
    return msg

def form_msgs(msgs): return [{"role":m[0],"content":m[1]} for m in msgs]        

# %% ../nbs/06_fn_to_fc.ipynb 32
def complete(
        messages: list[dict],  # The list of messages
        tools: list[dict] = [],  # The list of tools
    ) -> Tuple[str, str]:  # The role and content of the last message
    """Complete the conversation with the given message"""
    # Generate the response from GPT-4
    response = openai.chat.completions.create(model="gpt-4o", messages=messages, tools=tools)
    res = response.choices[0].message
    messages.append(res.to_dict())

    # Handle the tool response
    for call in res.to_dict().get('tool_calls', []):
        # Append the tool response to the list
        messages.append(
            form_msg(
                role="tool",
                content=fn_result_content(call, tools=tools),
                tool_call_id=call["id"]
            )
        )

    if res.to_dict().get('tool_calls'):
        # Recursively call the complete function to handle the tool response
        complete(
            messages, 
            tools=tools
        )

    # Return the last message
    return messages[-1]['role'], messages[-1]['content']
